# Nitro Enclave Architecture - Mobile Developer Briefing

**Date:** 2026-01-03
**Status:** DEPLOYED TO PRODUCTION
**Action Required:** Both iOS and Android need updates

---

## What Changed

We've replaced the **EC2-per-user vault model** with a **multi-tenant Nitro Enclave architecture**.

### Old Architecture (REMOVED)
```
User A → EC2 Instance A (vault-manager)
User B → EC2 Instance B (vault-manager)
User C → EC2 Instance C (vault-manager)
```
- Each user got their own EC2 instance
- 2-3 minute vault startup time
- Credential creation happened in Lambda (CEK stored in DynamoDB)
- Mobile encrypted password to UTK (User Transaction Key)
- Vault lifecycle: PROVISIONING → RUNNING → STOPPED

### New Architecture (DEPLOYED)
```
User A ─┐
User B ─┼──→ Single Nitro Enclave (shared, hardware-isolated)
User C ─┘
```
- All users share one Nitro Enclave (hardware-enforced isolation)
- **Sub-second vault activation** (no EC2 boot)
- Credential creation happens **inside the enclave** (sealed to hardware PCRs)
- Mobile **must verify attestation** before trusting enclave
- Mobile encrypts auth data **to enclave's public key** (not UTK)
- Vault status is always: `ENCLAVE_READY`

---

## What Mobile Apps Need to Change

### 1. Enrollment Flow Changes

#### `/vault/enroll/start` Response Changes

**NEW FIELDS in response:**
```json
{
  "enrollment_session_id": "enroll-xxx",
  "user_guid": "user-xxx",
  "transaction_keys": [...],
  "password_key_id": "tk-xxx",
  "next_step": "set_password",
  "attestation_required": false,

  "enclave_attestation": {
    "attestation_document": "base64-encoded-CBOR",
    "enclave_public_key": "base64-encoded-X25519-public-key",
    "nonce": "base64-encoded-32-byte-nonce",
    "expected_pcrs": [
      {
        "pcr0": "hex-encoded-48-bytes",
        "pcr1": "hex-encoded-48-bytes",
        "pcr2": "hex-encoded-48-bytes"
      }
    ]
  }
}
```

**CRITICAL:** The `enclave_attestation` field is now **always present** and **must be verified**.

#### New Mobile Responsibilities

1. **Parse the attestation document** (CBOR format)
2. **Verify the AWS Nitro certificate chain**
3. **Extract and compare PCR values** against `expected_pcrs`
4. **Extract the enclave's public key** from the attestation document
5. **Verify the public key matches** `enclave_public_key` in response
6. **Encrypt auth data to the enclave's public key** (not to UTK!)

### 2. Password Encryption Changes

**OLD (to UTK):**
```
1. Hash password with Argon2id
2. Generate ephemeral X25519 keypair
3. ECDH with UTK public key → shared secret
4. HKDF(shared_secret, "transaction-encryption-v1") → key
5. ChaCha20-Poly1305 encrypt password hash
6. Send: encrypted_password_hash, ephemeral_public_key, nonce, key_id
```

**NEW (to Enclave):**
```
1. Hash password with Argon2id
2. Generate ephemeral X25519 keypair
3. ECDH with ENCLAVE public key → shared secret  ← CHANGED (use enclave_attestation.enclave_public_key)
4. HKDF(shared_secret, "transaction-encryption-v1") → key  (SAME context for compatibility)
5. ChaCha20-Poly1305 encrypt password hash
6. Send: encrypted_password_hash, ephemeral_public_key, nonce, key_id
   (still send key_id for audit/backwards compatibility)
```

**Key change:** Encrypt to `enclave_attestation.enclave_public_key` instead of the UTK.
The HKDF context remains `"transaction-encryption-v1"` for compatibility.

### 3. Vault Lifecycle Changes

**REMOVED endpoints (no longer needed):**
- `POST /api/v1/vault/start` - Enclave is always running
- `POST /api/v1/vault/stop` - Cannot stop shared enclave
- `GET /api/v1/vault/status` - Still exists but always returns `ENCLAVE_READY`

**New behavior:**
- `vault_status` in finalize response is always `"ENCLAVE_READY"`
- No vault provisioning delay - enclave responds immediately
- No need to poll for vault startup

### 4. Credential Package Changes

**OLD `credential_package`:**
```json
{
  "user_guid": "user-xxx",
  "encrypted_blob": "base64...",
  "cek_version": 1,
  "ledger_auth_token": {...},
  "transaction_keys": [...]
}
```

**NEW `credential_package`:**
```json
{
  "user_guid": "user-xxx",
  "credential_id": "cred-xxx",
  "sealed_credential": "base64-enclave-sealed-blob",
  "enclave_public_key": "base64-identity-public-key",
  "backup_key": "base64-backup-encryption-key",
  "ledger_auth_token": {...},
  "transaction_keys": [...]
}
```

**Key differences:**
- `sealed_credential` replaces `encrypted_blob` - this is created **inside the enclave** and sealed to the hardware PCRs
- `enclave_public_key` is your identity public key (generated by enclave)
- `backup_key` is for credential backup encryption
- No `cek_version` - the enclave manages key versions internally

---

## Nitro Attestation Verification (REQUIRED)

### What is Nitro Attestation?

AWS Nitro Enclaves provide **hardware-based attestation** that cryptographically proves:
1. The enclave is running genuine AWS Nitro hardware
2. The enclave is running the exact code we deployed (via PCR hashes)
3. The public key belongs to that specific enclave instance

### Attestation Document Structure

The `attestation_document` is CBOR-encoded with this structure:
```
COSE_Sign1 {
  protected: { alg: ES384 },
  payload: {
    module_id: "nitro-enclave-xxx",
    timestamp: 1234567890,
    pcrs: {
      0: bytes(48),  // Enclave image hash
      1: bytes(48),  // Linux kernel hash
      2: bytes(48),  // Application hash
    },
    public_key: bytes(32),  // X25519 enclave public key
    certificate: bytes(...), // AWS Nitro certificate
    cabundle: [bytes(...), ...] // Certificate chain to AWS root
  }
}
```

### Verification Steps

#### Step 1: Parse CBOR
```swift
// iOS (using SwiftCBOR or similar)
let cborData = Data(base64Encoded: attestationDocument)!
let cose = try CBOR.decode(cborData)
let payload = cose["payload"]
```

```kotlin
// Android (using cbor-java or kotlinx-serialization-cbor)
val cborData = Base64.decode(attestationDocument, Base64.DEFAULT)
val cose = Cbor.decodeFromByteArray<CoseSign1>(cborData)
```

#### Step 2: Verify Certificate Chain
```swift
// iOS
let certificate = SecCertificateCreateWithData(nil, payload["certificate"] as CFData)
let cabundle = (payload["cabundle"] as [Data]).map {
    SecCertificateCreateWithData(nil, $0 as CFData)!
}

// Create trust with AWS Nitro root CA
var trust: SecTrust?
SecTrustCreateWithCertificates([certificate] + cabundle, policy, &trust)
SecTrustEvaluateAsyncWithError(trust!) { trust, result, error in
    // Verify result is true
}
```

```kotlin
// Android (using Bouncy Castle)
val cf = CertificateFactory.getInstance("X.509", "BC")
val cert = cf.generateCertificate(ByteArrayInputStream(certBytes))
val chain = cabundle.map { cf.generateCertificate(ByteArrayInputStream(it)) }

// Verify against AWS Nitro root CA (embedded in app)
val trustAnchors = setOf(TrustAnchor(awsNitroRootCert, null))
val pkixParams = PKIXParameters(trustAnchors)
val certPath = cf.generateCertPath(listOf(cert) + chain)
CertPathValidator.getInstance("PKIX").validate(certPath, pkixParams)
```

#### Step 3: Compare PCR Values
```swift
// iOS
let pcr0 = payload["pcrs"][0] as Data
let pcr1 = payload["pcrs"][1] as Data
let pcr2 = payload["pcrs"][2] as Data

// Compare against expected values from response
let expected = response.enclaveAttestation.expectedPcrs[0]
guard pcr0.hexString == expected.pcr0,
      pcr1.hexString == expected.pcr1,
      pcr2.hexString == expected.pcr2 else {
    throw AttestationError.pcrMismatch
}
```

```kotlin
// Android
val pcr0 = payload.pcrs[0].toHexString()
val pcr1 = payload.pcrs[1].toHexString()
val pcr2 = payload.pcrs[2].toHexString()

val expected = response.enclaveAttestation.expectedPcrs[0]
require(pcr0 == expected.pcr0) { "PCR0 mismatch" }
require(pcr1 == expected.pcr1) { "PCR1 mismatch" }
require(pcr2 == expected.pcr2) { "PCR2 mismatch" }
```

#### Step 4: Verify Enclave Public Key
```swift
// iOS
let attestedPublicKey = payload["public_key"] as Data
let responsePublicKey = Data(base64Encoded: response.enclaveAttestation.enclavePublicKey)!

guard attestedPublicKey == responsePublicKey else {
    throw AttestationError.publicKeyMismatch
}
```

```kotlin
// Android
val attestedPublicKey = payload.publicKey
val responsePublicKey = Base64.decode(response.enclaveAttestation.enclavePublicKey, Base64.DEFAULT)

require(attestedPublicKey.contentEquals(responsePublicKey)) { "Public key mismatch" }
```

---

## Updated Enrollment Flow

```
┌─────────┐                    ┌─────────┐                    ┌─────────┐
│  Mobile │                    │  Lambda │                    │ Enclave │
└────┬────┘                    └────┬────┘                    └────┬────┘
     │                              │                              │
     │  POST /vault/enroll/start   │                              │
     │─────────────────────────────>│                              │
     │                              │   Request attestation        │
     │                              │─────────────────────────────>│
     │                              │   Attestation + public key   │
     │                              │<─────────────────────────────│
     │   enclave_attestation        │                              │
     │<─────────────────────────────│                              │
     │                              │                              │
     │  ┌─────────────────────┐     │                              │
     │  │ VERIFY ATTESTATION  │     │                              │
     │  │ 1. Parse CBOR       │     │                              │
     │  │ 2. Verify cert chain│     │                              │
     │  │ 3. Compare PCRs     │     │                              │
     │  │ 4. Verify public key│     │                              │
     │  └─────────────────────┘     │                              │
     │                              │                              │
     │  Encrypt password to         │                              │
     │  enclave public key          │                              │
     │                              │                              │
     │  POST /vault/enroll/set-password                            │
     │─────────────────────────────>│                              │
     │                              │   Forward encrypted auth     │
     │                              │─────────────────────────────>│
     │                              │   (stored for finalize)      │
     │   OK                         │                              │
     │<─────────────────────────────│                              │
     │                              │                              │
     │  POST /vault/enroll/finalize │                              │
     │─────────────────────────────>│                              │
     │                              │   Create sealed credential   │
     │                              │─────────────────────────────>│
     │                              │   Sealed credential + keys   │
     │                              │<─────────────────────────────│
     │   credential_package         │                              │
     │<─────────────────────────────│                              │
     │                              │                              │
```

---

## Testing Requirements

### What to Test

1. **Attestation parsing** - Can you parse the CBOR attestation document?
2. **Certificate verification** - Does the Nitro certificate chain validate?
3. **PCR comparison** - Do extracted PCRs match expected values?
4. **Key extraction** - Can you extract the enclave public key?
5. **Encryption** - Can you encrypt auth data to the enclave's key?
6. **Full flow** - Does enrollment complete successfully?

### Test Invitation

Use this invitation code for testing:
- **Code:** (create fresh via `/test/create-invitation`)
- **Note:** Old invitations won't work - they reference the old architecture

### Expected Results

1. `/vault/enroll/start` returns `enclave_attestation` object
2. Attestation document parses as valid CBOR
3. Certificate chain validates to AWS Nitro root
4. PCR values match expected values
5. `/vault/enroll/finalize` returns `vault_status: "ENCLAVE_READY"`
6. Credential package contains `sealed_credential` (not `encrypted_blob`)

### Debugging Tips

- **Attestation parse failure:** Check Base64 decoding, CBOR library compatibility
- **Certificate verification failure:** Ensure you have AWS Nitro root CA embedded
- **PCR mismatch:** Check hex encoding (lowercase, no prefix)
- **Encryption failure:** Verify HKDF context is `"enclave-auth-v1"`

---

## Migration Checklist

### iOS
- [ ] Add CBOR parsing library (SwiftCBOR or similar)
- [ ] Implement `NitroAttestationVerifier` class
- [ ] Update `EnrollmentService.startEnrollment()` to extract attestation
- [ ] Add attestation verification before `setPassword()`
- [ ] Update password encryption to use enclave public key
- [ ] Update HKDF context to `"enclave-auth-v1"`
- [ ] Update credential storage for new `sealed_credential` format
- [ ] Remove vault start/stop UI (no longer needed)
- [ ] Test full enrollment flow

### Android
- [ ] Add CBOR parsing library (cbor-java or kotlinx-serialization-cbor)
- [ ] Implement `NitroAttestationVerifier` class
- [ ] Update `EnrollmentViewModel` to extract attestation
- [ ] Add attestation verification before `setPassword()`
- [ ] Update `CryptoManager.encryptPasswordForServer()` to use enclave key
- [ ] Update HKDF context to `"enclave-auth-v1"`
- [ ] Update credential storage for new `sealed_credential` format
- [ ] Remove vault lifecycle controls (no longer needed)
- [ ] Test full enrollment flow

---

## Resources

- AWS Nitro Enclaves documentation: https://docs.aws.amazon.com/enclaves/
- Attestation document format: https://docs.aws.amazon.com/enclaves/latest/user/verify-root.html
- AWS Nitro root CA: (embedded in app - ask backend team)
- CBOR RFC: https://datatracker.ietf.org/doc/html/rfc8949

---

## Questions?

Contact the backend team via the usual channels. We can provide:
- Sample attestation documents for testing
- AWS Nitro root CA certificate
- Debug builds with verbose logging
